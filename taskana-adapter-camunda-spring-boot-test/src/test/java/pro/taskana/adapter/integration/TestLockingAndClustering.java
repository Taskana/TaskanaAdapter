package pro.taskana.adapter.integration;

import static org.assertj.core.api.Assertions.assertThat;

import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.security.auth.Subject;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.test.context.ContextConfiguration;
import pro.taskana.adapter.camunda.outbox.rest.resource.CamundaTaskEventListResource;
import pro.taskana.adapter.impl.TaskanaTaskStarter;
import pro.taskana.adapter.impl.TaskanaTaskTerminator;
import pro.taskana.adapter.systemconnector.camunda.api.impl.HttpHeaderProvider;
import pro.taskana.adapter.test.TaskanaAdapterTestApplication;
import pro.taskana.common.api.security.UserPrincipal;
import pro.taskana.common.test.security.JaasExtension;
import pro.taskana.common.test.security.WithAccessId;
import pro.taskana.common.test.util.ParallelThreadHelper;
import pro.taskana.task.api.TaskState;
import pro.taskana.task.api.models.TaskSummary;


/**
 * Test class to test the conversion of tasks generated by Camunda BPM to Taskana tasks.
 */
@SpringBootTest(
    classes = TaskanaAdapterTestApplication.class,
    webEnvironment = WebEnvironment.DEFINED_PORT)
@AutoConfigureWebTestClient
@ExtendWith(JaasExtension.class)
@ContextConfiguration
@SuppressWarnings("checkstyle:LineLength")
class TestLockingAndClustering extends AbsIntegrationTest {

  private static final String BASIC_OUTBOX_PATH = "http://localhost:10020/outbox-rest/events";

  @LocalServerPort
  private Integer port;
  @Autowired
  private HttpHeaderProvider httpHeaderProvider;
  @Autowired
  TaskanaTaskStarter taskanaTaskStarter;
  @Autowired
  TaskanaTaskTerminator taskanaTaskTerminator;

  @Value("${taskana-system-connector-camundaSystemURLs}")
  private String configuredSystemConnectorUrls;

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  void should_LockEventsForTheCorrectTime_When_Getting() {
    TestRestTemplate restTemplate =
        new TestRestTemplate(
            new RestTemplateBuilder()
                .rootUri("http://localhost:" + port)
                .requestFactory(HttpComponentsClientHttpRequestFactory.class));
    this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_process", "");

    String url = BASIC_OUTBOX_PATH + "?lock-for=10";

    HttpEntity<Void> requestEntity = httpHeaderProvider.prepareNewEntityForOutboxRestApi();
    ResponseEntity<CamundaTaskEventListResource> answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).hasSize(1);
    answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).isEmpty();

    try {
      Thread.sleep(10000);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    answer =
        restTemplate.exchange(
            url, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);

    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).hasSize(1);

  }

  @WithAccessId(
      user = "teamlead_1",
      groups = {"taskadmin"})
  @Test
  void should_UnlockTheEvent() {
    TestRestTemplate restTemplate =
        new TestRestTemplate(
            new RestTemplateBuilder()
                .rootUri("http://localhost:" + port)
                .requestFactory(HttpComponentsClientHttpRequestFactory.class));
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_user_task_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(1);
    String urlWithLock = BASIC_OUTBOX_PATH + "?lock-for=10";

    HttpEntity<Void> requestEntity = httpHeaderProvider.prepareNewEntityForOutboxRestApi();
    ResponseEntity<CamundaTaskEventListResource> answer = restTemplate.exchange(
            urlWithLock, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);
    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).hasSize(1);
    int eventId = answer.getBody().getCamundaTaskEvents().get(0).getId();
    String urlWithUnlock = BASIC_OUTBOX_PATH + "/unlock-event/" + eventId;

    restTemplate.postForObject(urlWithUnlock, requestEntity, String.class);
    answer =
        restTemplate.exchange(
            urlWithLock, HttpMethod.GET, requestEntity, CamundaTaskEventListResource.class);
    assertThat(answer.getBody()).isNotNull();
    assertThat(answer.getBody().getCamundaTaskEvents()).hasSize(1);

  }

  @WithAccessId(user = "taskadmin")
  @Test
  void should_CreateCorrespondingTaskanaTasksConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("admin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          taskanaTaskStarter.retrieveReferencedTasksAndCreateCorrespondingTaskanaTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    for (String externalId : camundaTaskIds) {
      List<TaskSummary> tasks = taskService.createTaskQuery().externalIdIn(externalId).list();
      assertThat(tasks).hasSize(1);
    }
  }

  @WithAccessId(user = "taskadmin")
  @Test
  void should_FinishCorrespondingTaskanaTasksConcurrently() throws Exception {
    String processInstanceId = this.camundaProcessengineRequester.startCamundaProcessAndReturnId(
        "simple_multiple_execution_process", "");
    List<String> camundaTaskIds =
        this.camundaProcessengineRequester.getTaskIdsFromProcessInstanceId(processInstanceId);
    assertThat(camundaTaskIds).hasSize(3);
    Thread.sleep((long) (this.adapterTaskPollingInterval * 1.2));

    for (String camundaTaskId : camundaTaskIds) {
      this.camundaProcessengineRequester.completeTaskWithId(camundaTaskId);
    }
    List<String> accessIds =
        Collections.synchronizedList(
            Stream.of("taskadmin", "taskadmin", "taskadmin")
                .collect(Collectors.toList()));
    PrivilegedAction<Void> action =
        () -> {
          taskanaTaskTerminator.retrieveFinishedReferencedTasksAndTerminateCorrespondingTaskanaTasks();
          return null;
        };
    ParallelThreadHelper.runInThread(
        getRunnableTest(accessIds, action), accessIds.size());
    for (String externalId : camundaTaskIds) {
      List<TaskSummary> tasks = taskService.createTaskQuery().externalIdIn(externalId).list();
      assertThat(tasks).hasSize(1);
      assertThat(tasks.get(0).getState()).isEqualTo(TaskState.COMPLETED);
    }
  }

  private Runnable getRunnableTest(List<String> accessIds, PrivilegedAction<Void> action) {
    return () -> {
      Subject subject = new Subject();
      subject.getPrincipals().add(new UserPrincipal(accessIds.remove(0)));
      Subject.doAs(subject, action);
    };
  }

}
